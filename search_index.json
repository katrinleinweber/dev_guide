[
["index.html", "rOpenSci Packages: Development, Maintenance, and Peer Review Preface", " rOpenSci Packages: Development, Maintenance, and Peer Review rOpenSci onboarding editorial team: Scott Chamberlain, Anna Krystalli, Lincoln Mullen, Karthik Ram, Noam Ross, Maëlle Salmon 2018-06-29 Preface This book has the ambition to become a guide for maintainers of rOpenSci packages, in particular volunteers who submit a package to onboarding. The first section of the book presents our guidelines for building and testing your package. The second section is dedicated to onboarding: what it is, our policies, and specific guides for authors, editors and reviewers. The third and last section features our best practice for nurturing your package once it has been onboarded: how to collaborate with other developers, how to document releases, how to promote your package and how to leverage GitHub as a development platform. The third section also features a chapter for anyone wishing to start contributing to rOpenSci packages. We hope that you’ll find the guide useful and clear, and welcome your suggestions in the issue tracker of the book. Happy R packaging! The rOpenSci editorial team. If you want to contribute to this book (suggestions, corrections) please refer to its GitHub repository in particular the contributing guidelines. Thanks! We are thankful for all authors, reviewers and guest editors for helping us improve the system and this guide over the years. Thanks also to the following persons who made direct edits to this guide here or in its former home at ropensci/onboarding or ropensci/packaging_guide: Katrin Leinweber, John Baumgartner, François Michonneau, Christophe Dervieux, Lorenzo Busetto, Ben Marwick, Nicholas Horton, Chris Kennedy, Mark Padgham, Jeroen Ooms, Sean Hughes, Jan Gorecki, Joseph Stachelek, Dean Attali, Julia Gustavsen, Nicholas Tierney, Rich FitzJohn, Tiffany Timbers, Hilmar Lapp, Miles McBain, Bryce Mecum, Jonathan Carroll, Carl Boettiger. Please tell us if we forgot to acknowledge your contribution! "],
["building.html", "Chapter 1 Packaging Guide 1.1 Package name and metadata 1.2 Function/variable naming &amp; general syntax 1.3 README 1.4 Documentation 1.5 Documentation website 1.6 Authorship 1.7 Testing 1.8 Examples 1.9 Package dependencies 1.10 Recommended scaffolding 1.11 Console messages 1.12 Miscellaneous CRAN gotchas 1.13 Further guidance", " Chapter 1 Packaging Guide rOpenSci accepts packages that meet our guidelines via a streamlined onboarding process. To ensure a consistent style across all of our tools we have written this chapter highlighting our guidelines for package development. Please also read and apply our chapter about continuous integration. Further guidance for after onboarding is provided in the third section of this book starting with a chapter about collaboration. We strongly recommend that package developers read Hadley Wickham’s concise but thorough book on package development which is available for free online (and print). 1.1 Package name and metadata 1.1.1 Naming your package We strongly recommend short, descriptive names in lower case. If your package deals with one or more commercial services, please make sure the name does not violate branding guidelines. You can check if your package name is available, informative and not offensive by using the available package. A more unique package name might be easier to track (for you and us to assess package use) and search (for users to find it and to google their questions). Obviously a too unique package name might make the package less discoverable (e.g. it might be an argument for naming your package geojson). Find other interesting aspects of naming your package in this blog post by Nick Tierney, and in case you change your mind, find out how to rename your package in this other blog post of Nick’s. 1.1.2 Creating metadata for your package We recommend you to use the codemetar package for creating and updating a JSON CodeMeta metadata file for your package via codemetar::write_codemeta(). It will automatically include all useful information, including GitHub rep keywords. CodeMeta uses Schema.org terms so as it gains popularity the JSON metadata of your package might be used by third-party services, maybe even search engines. 1.2 Function/variable naming &amp; general syntax We strongly recommend snake_case over all other styles unless you are porting over a package that is already in wide use. Avoid function name conflicts with base packages or other popular ones (e.g. ggplot2, dplyr, magrittr, data.table) Functions and arguments naming should be chosen work together to form a common, logical programming API that is easy to read, and autocomplete. Consider an object_verb() naming scheme for functions in your package that take a common data type or interact with a common API. object refers to the data/API and verb the primary action. This scheme helps avoid namespace conflicts with packages that may have similar verbs, and makes code readable and easy to auto-complete. For instance, in stringi, functions starting with stri_ manipulate strings (stri_join(), stri_sort(), and in googlesheets functions starting with gs_ are calls to the Google Sheets API (gs_auth(), gs_user(), gs_download()). Argument naming and order should be consistent across functions that use similar inputs. For functions that manipulate an object/data and return an object/data of the same type, make the object/data the first argument of the function so as to enhance compatibility with the pipe operator (%&gt;%) Package functions importing data should not import data to the global environment, but instead must return objects. Assignments to the global environment are to be avoided in general. For more information on how to style your code, name functions, and R scripts inside the R/ folder, we recommend reading the code chapter in Hadley’s book. We recommend the styler package for automating part of the code styling. 1.3 README All packages should have a README file, named README.md, in the root of the repository. The README should include, from top to bottom: The package name Badges for continuous integration and test coverage, the badge for rOpenSci peer-review once it has started (see below), a repostatus.org badge, and any other badges Short description of goals of package, with descriptive links to all vignettes (renderred, i.e. readable, cf the documentation website section) unless the package is small and there’s only one vignette repeating the README. Installation instructions Any additional setup required (authentication tokens, etc) Brief demonstration usage If applicable, how the package compares to other similar packages and/or how it relates to other packages Citation information If you use another repo status badge such as a lifecycle badge, please also add a repostatus.org badge. Example of a repo README with two repo status badges. Once you have submitted a package and it has passed editor checks, add a peer-review badge via [![](https://badges.ropensci.org/&lt;issue_id&gt;_status.svg)](https://github.com/ropensci/onboarding/issues/&lt;issue_id&gt;) where issue_id is the number of the issue in the onboarding repository. For instance, the badge for rtimicropem review uses the number 126 since it’s the review issue number. The badge will first indicated “under review” and then “peer-reviewed” once your package has been onboarded (issue labelled “approved” and closed), and will link to the review issue. If your README has many badges consider ordering them in an html table to make it easier for newcomers to gather information at a glance. See examples in drake repo and in qualtRics repo. Possible sections are Development (CI statuses cf CI chapter, Slack channel for discussion, repostatus) Release/Published (CRAN version and release date badges from METACRAN, CRAN checks API badge, Zenodo badge) Stats/usage (downloads e.g. download badges from METACRAN) The table should be more wide than it is long in order to mask the rest of the README. If your package connects to a data source or online service, or wraps other software, consider that your package README may be the first point of entry for users. It should provide enough information for users to understand the nature of the data, service, or software, and provide links to other relevant data and documentation. For instance, a README should not merely read, “Provides access to GooberDB,” but also include, &quot;…, an online repository of Goober sightings in South America. More information about GooberDB, and documentation of database structure and metadata can be found at link. We recommend not creating README.md directly, but from a README.Rmd file (an Rmarkdown file) if you have any demonstration code. The advantage of the .Rmd file is you can combine text with code that can be easily updated whenever your package is updated. Extensive examples should be kept for a vignette. If you want to make the vignettes more accessible before installing the package, we suggest creating a website for your package Consider using devtools::use_readme_rmd() to get a template for a README.Rmd file and to automatically set up a pre-commit hook to ensure that README.md is always newer than README.Rmd. After a package is accepted but before transfer, the rOpenSci footer should be added to the bottom of the README file with the following markdown line: [![ropensci_footer](http://ropensci.org/public_images/github_footer.png)](https://ropensci.org) Add a code of conduct and contribution guidelines, cf this section of the book. See the gistr README for a good example README to follow for a small package, and bowerbird README for a good example README for a larger package. 1.4 Documentation All exported package functions should be fully documented with examples. All functions should document the type of object returned under the @return heading. The package should contain top-level documentation for ?foobar, (or ?foobar-package if there is a naming conflict). Optionally, you can use both ?foobar and ?foobar-package for the package level manual file, using @aliases roxygen tag. usethis::use_package_doc() adds the template for the top-level documentation. The package should contain at least one vignette providing a substantial coverage of package functions, illustrating realistic use cases and how functions are intended to interact. If the package is small, the vignette and the README can have the same content. As is the case for a README, top-level documentation or vignettes may be the first point of entry for users. If your package connects to a data source or online service, or wraps other software, it should provide enough information for users to understand the nature of the data, service, or software, and provide links to other relevant data and documentation. For instance, a the vignette intro or documentation should not merely read, “Provides access to GooberDB,” but also include, &quot;…, an online repository of Goober sightings in South America. More information about GooberDB, and documentation of database structure and metadata can be found at link. Any vignette should outline prerequisite knowledge to be able to understand vignette up front. The general vignette should present a series of examples progressing in complexity from basic to advanced usage. Functionality likely to be used by only more advanced users or developers might be better put in a separate vignette (i.e. programming/NSE with dplyr). The vignette(s) should include citations to software and papers where appropriate. We request all submissions to use roxygen2 for documentation. roxygen2 is an R package that automatically compiles .Rd files to your man folder in your package from simple tags written above each function. More information on using roxygen2 documentation is available in the R packages book. One key advantage of using roxygen2 is that your NAMESPACE will always be automatically generated and up to date. When using roxygen2, add #' @noRd to internal functions. Only use package startup messages when necessary (function masking for instance). Avoid package startup messages like “This is foobar 2.4-0” or citation guidance because they can be annoying to the user. Rely on documentation for such guidance. You can choose to have a README section about use cases of your package (other packages, blog posts, etc), example. 1.5 Documentation website We recommend creating a documentation website for your package using pkgdown. Here is a good tutorial to get started with pkgdown. When your package has many functions, use grouping in the reference: see the example of drake website and associated config file. You could use the tic package for automatic deployment of the package’s website, see this example repo. This would save you the hassle of running (and remembering to run) pkgdown::build_site() yourself every time the site needs to be updated. First refer to our chapter on continuous integration if you’re not familiar with continuous integration/Travis. 1.6 Authorship The DESCRIPTION file of a package should list package authors and contributors to a package, using the Authors@R syntax to indicate their roles (author/creator/contributor etc.) if there is more than one author. See this section of “Writing R Extensions” for details. If you feel that your reviewers have made a substantial contribution to the development of your package, you may list them in the Authors@R field with a Reviewer contributor type (&quot;rev&quot;), like so: person(&quot;Bea&quot;, &quot;Hernández&quot;, role = &quot;rev&quot;, comment = &quot;Bea reviewed the package for ropensci, see &lt;https://github.com/ropensci/onboarding/issues/116&gt;&quot;), Only include reviewers after asking for their consent. Read more in this blog post “Thanking Your Reviewers: Gratitude through Semantic Metadata”. Note that ‘rev’ will raise a CRAN NOTE unless the package is built using R v3.5. As of June 2018 you need to use roxygen2 dev version for the list of authors in the package-level documentation to be compiled properly with the “rev” role (because this is a MARC role not included yet in royxgen2 CRAN version from February 2017). Please do not list editors as contributors. Your participation in and contribution to rOpenSci is thanks enough! 1.7 Testing All packages should pass R CMD check/devtools::check() on all major platforms. All packages should have a test suite that covers major functionality of the package. The tests should also cover the behavior of the package in case of errors. We recommend using testthat for writing tests. Strive to write tests as you write each new function. This serves the obvious need to have proper testing for the package, but allows you to think about various ways in which a function can fail, and to defensively code against those. More information. Once you’ve set up CI, use your package’s code coverage report (cf this section of our book) to identify untested lines, and to add further tests. testthat has a function skip_on_cran() that you can use to not run tests on CRAN. We recommend using this on all functions that are API calls since they are quite likely to fail on CRAN. These tests will still run on Travis. Even if you use continuous integration, we recommend that you run tests locally prior to submitting your package, as some tests are often skipped. (You may need to set Sys.setenv(NOT_CRAN=&quot;true&quot;) in order to ensure all tests are run.) In addition, we recommend that prior to submitting your package, you use MangTheCat’s goodpractice package to check your package for likely sources of errors, and run spelling::spell_check_package() to find spelling errors in documentation. 1.8 Examples Include extensive examples in the documentation. In addition to demonstrating how to use the package, these can act as an easy way to test package functionality before there are proper tests. However, keep in mind we require tests in contributed packages. If you prefer not to clutter up code with extensive documentation, place further documentation/examples in files in a man-roxygen folder in the root of your package, and those will be combined into the manual file by the use of @template &lt;file name&gt;, for example. You can run examples with devtools::run_examples(). 1.9 Package dependencies Use Imports instead of Depends for packages providing functions from other packages. Make sure to list packages used for testing (testthat), and documentation (knitr, roxygen2) in your Suggests section of package dependencies. If you use any packages in your examples sections, make sure to list those, if not already listed elsewhere, in Suggests section of package dependencies. For most cases where you must expose functions from dependencies to the user, you should import and re-export those individual functions rather than listing them in the Depends fields. For instance, if functions in your package produce raster objects, you might re-export only printing and plotting functions from the raster package. If your package uses a system dependency, you should indicate it in DESCRIPTION and check for it in the configure script and give a helpful error message if it cannot be found. Example of a line indicating a system dependency in DESCRIPTION, example of how a configure script checks for the dependency. You should also check the dependency is listed by sysreqsdb in order to ensure automatic tools building packages don’t have a hard time with your package. See sysreqsdb contributing guidelines. 1.10 Recommended scaffolding For http requests we strongly recommend using httr over RCurl. For parsing JSON, use jsonlite instead of rjson or RJSONIO. For parsing, creating, and manipulating XML, we strongly recommend xml2 for most cases. 1.11 Console messages Use message() and warning() to communicate with the user in your functions. Please do not use print() or cat() unless it’s for a print.*() method, as these methods of printing messages are harder for the user to suppress. 1.12 Miscellaneous CRAN gotchas This is a collection of CRAN gotchas that are worth avoiding at the outset. Make sure your package title is in Title Case. Do not put a period on the end of your title Avoid starting the description with the package name or This package … Make sure you include links to websites if you wrap a web API, scrape data from a site, etc. in the Description field of your DESCRIPTION file Avoid long running tests and examples. Consider testthat::skip_on_cran in tests to skip things that take a long time but still test them locally and on Travis. Include top-level files such as paper.md, .travis.yml in your .Rbuildignore file. 1.13 Further guidance Hadley Wickham’s R Packages is an excellent, readable resource on package development which is available for free online (and print). Writing R Extensions is the canonical, usually most up-to-date, reference for creating R packages. If you are submitting a package to rOpenSci via the onboarding repo, you can direct further questions to the rOpenSci team in the issue tracker, or in our discussion forum. Before submitting a package use the goodpractice package (goodpractice::gp()) as a guide to improve your package, since most exceptions to it will need to be justified. E.g. the use of foo might be generally bad and therefore flagged by goodpractice but you had a good reason to use it in your package. "],
["ci.html", "Chapter 2 Continuous Integration Best Practices 2.1 Why use continuous integration? 2.2 How to use continuous integration? 2.3 Which continuous integration service(s)? 2.4 Test coverage 2.5 Even more CI: OpenCPU 2.6 Make more of your CI builds: tic", " Chapter 2 Continuous Integration Best Practices This chapter summarizes our guidelines about continuous integration after explaining what continuous integration. Along with last chapter, it forms our guidelines for onboarding reviews. 2.1 Why use continuous integration? All rOpenSci packages must use one form of continuous integration. This ensures that all commits, pull requests, and new branches are run through R CMD check. rOpenSci packages continuous integration must also be linked to a code coverage service, indicating how many lines are covered by unit tests. Both test status and code coverage should be reported via badges in your package README. 2.2 How to use continuous integration? The usethis package offers a few functions for continuous integration setup, see the docs. Details will be provided below for different services. 2.3 Which continuous integration service(s)? Different continuous integration services will support builds on different operating system. R packages should have CI for all platforms when they contain: Compiled code Java dependencies Dependencies on other languages Packages with system calls Text munging e.g. getting people’s names (in order to find encoding issues). Anything with file system / path calls 2.3.1 Travis CI (Linux and Mac OSX) Travis offers continuous integration for Linux and Mac OSX. Set it up using usethis::use_travis(). R is now a natively supported language on Travis-CI, making it easier than ever to do continuous integration. See R Packages and Julia Silge’s Beginner’s Guide to Travis-CI for R for more help. Please use these tips to minimize build time on Travis especially after your package project gets transferred to ropensci Travis account: Cache installation of packages. Add cache: packages at the beginning of the config file. Example in the wild. It’ll already be in the config file if you set Travis up using usethis::use_travis(). Enable auto-cancellation of builds. 2.3.2 Appveyor CI (Windows) For continuous integration on Windows, see R + Appveyor. Set it up using usethis::use_appveyor(). Here are tips to minimize Appveyor build time: Cache installation of packages. Example in a config file. It’ll already be in the config file if you set Appveyor CI up using usethis::use_appveyor(). Enable rolling builds. We no longer transfer Appveyor projects to ropensci Appveyor account so after transfer of your repo to the ropensci GitHub organization the badge will be [![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/ropensci/pkgname?branch=master&amp;svg=true)](https://ci.appveyor.com/project/individualaccount/pkgname). 2.3.3 Circle CI Circle CI is e.g. used by rOpenSci package bomrang as an alternative to Travis CI. 2.4 Test coverage Continuous integration should also include reporting of test coverage via a testing service such as CodeCov or Coveralls. See the README for the covr package for instructions, as well as usethis::use_coverage(). If you run coverage on several CI services the results will be merged. 2.5 Even more CI: OpenCPU After transfer to the ropensci organization, each push to the repo will be built on OpenCPU and the person committing will receive a notification email. This allows an additional CI service for package authors that that allows for R functions in packages to be called remotely via https://ropensci.ocpu.io/ using the opencpu api. For more details about this service consult the OpenCPU help page that also indicates where to ask questions. 2.6 Make more of your CI builds: tic The tic package facilitates deployment tasks for R packages tested by Travis CI, AppVeyor, or the CI tool of your choice, cf e.g. our suggestion to build and deploy the documentation website of your package via Travis. Actually this book uses tic for deployment. "],
["package-development-security-best-practices.html", "Chapter 3 Package Development Security Best Practices 3.1 Misc", " Chapter 3 Package Development Security Best Practices This chapter isn’t written yet. It should mention the elements outlined in this bookdown (repo) started at the unconf 2017, or have a link to this book/a similar book when written. Also interesting are these unconf projects: the notary package the security-related projects of unconf18 3.1 Misc We recommend you secure your GitHub account with 2FA. "],
["onboardingintro.html", "Chapter 4 Onboarding, Why? What? 4.1 Why submit your package to rOpenSci? 4.2 Why review packages for rOpenSci? 4.3 Why are reviews open? 4.4 Editors and reviewers", " Chapter 4 Onboarding, Why? What? This chapter is a general intro to our onboarding system of packages. rOpenSci’s suite of packages is partly contributed by staff members and partly contributed by community members, which means the suite stems from a great diversity of skills and experience of developers. How to ensure quality for the whole set? That’s where onboarding comes into play: packages contributed by the community undergo a transparent, constructive, non adversarial and open review process. For that process relying mostly on volunteer work, associate editors manage the incoming flow and ensure progress of submissions; authors create, submit and improve their package; reviewers, two per submission, examine the software code and user experience. This blog post written by rOpenSci onboarding editors is a good introduction to rOpenSci onboarding. Other blog posts about onboarding itself and onboarded packages can be find via the “onboarding” tag on rOpenSci blog. Technically, we make the most of GitHub infrastructure: each package onboarding process is an issue in the ropensci/onboarding GitHub repository. For instance, click here to read the onboarding review thread of the ropenaq package: the process is an ongoing conversation until acceptance of the package, with two external reviews as important milestones. Furthermore, we use GitHub features such as the use of issue templates (as submission templates), and such as labelling which we use to track progress of submissions (from editor checks to approval). 4.1 Why submit your package to rOpenSci? First, and foremost, we hope you submit your package for review because you value the feedback. We aim to provide useful feedback to package authors and for our review process to be open, non-adversarial, and focused on improving software quality. Once aboard, your package will continue to receive support from rOpenSci members. You’ll retain ownership and control of of your package, but we can help with ongoing maintenance issues such as those associated with updates to R and dependencies and CRAN policies. rOpenSci will promote your package through our web page, blog, and social media. Packages in our suite are also distributed via our drat repository and Docker images, and listed in our task views. rOpenSci packages can be cross-listed with other repositories such as CRAN and BioConductor. rOpenSci packages that contain a short accompanying paper can, after review, be automatically submitted to the Journal of Open-Source Software for fast-tracked publication. 4.2 Why review packages for rOpenSci? As in any peer-review process, we hope you choose to review to give back to the rOpenSci and scientific communities. Our mission to expand access to scientific data and promote a culture of reproducible research is only possible through the volunteer efforts of community members like you. Review is a two-way conversation. By reviewing packages, you’ll have the chance to continue to learn development practices from authors and other reviewers. The open nature of our review process allows you to network and meet colleagues and collaborators through the review process. Our community is friendly and filled with supportive members expert in R development and many other areas of science and scientific computing. To volunteer to be one of our reviewers, just click here to fill out a short form providing your contact information and areas or expertise. We are always looking for more reviewers with both general package-writing experience and domain expertise in the fields packages are used for. 4.3 Why are reviews open? Our reviewing threads are public. Authors, reviewers, and editors all know each other’s identities. The broader community can view or even participate in the conversation as it happens. This provides an incentive to be thorough and provide non-adversarial, constructive reviews. Both authors and reviewers report that they enjoy and learn more from this open and direct exchange. It also has the benefit of building community. Participants have the opportunity to meaningfully network with new peers, and new collaborations have emerged via ideas spawned during the review process. We are aware that open systems can have drawbacks. For instance, in traditional academic review, double-blind peer review can increase representation of female authors, suggesting bias in non-blind reviews. It is also possible reviewers are less critical in open review. However, we posit that the openness of the review conversation provides a check on review quality and bias; it’s harder to inject unsupported or subjective comments in public and without the cover of anonymity. Ultimately, we believe the ability of authors and reviewers to have direct but public communication improves quality and fairness. Furthermore, authors and reviewers have the ability to contact privately the editors for any doubt or question they might have. 4.4 Editors and reviewers 4.4.1 Associate editors rOpenSci’s onboarding process is run by: Noam Ross, EcoHealth Alliance Scott Chamberlain, rOpenSci Karthik Ram, rOpenSci Maëlle Salmon, rOpenSci Lincoln Mullen, George Mason University Anna Krystalli, University of Sheffield RSE 4.4.2 Reviewers We are grateful to the following individuals who have offered up their time and expertise to review packages submitted to rOpenSci. Toph Allen · Brooke Anderson · Alison Appling · Zebulun Arendsee · Taylor Arnold · Dean Attali · Mara Averick · Suzan Baert · James Balamuta · Joëlle Barido-Sottani · Cale Basaraba · John Baumgartner · Marcus Beck · Gabe Becker · Jason Becker · Kenneth Benoit · Aaron Berdanier · Carl Boettiger · Ben Bond-Lamberty · Alison Boyer · Jenny Bryan · Lorenzo Busetto · Jorge Cimentada · Jon Clayden · Will Cornwell · Ildiko Czeller · Laura DeCicco · Christophe Dervieux · Amanda Dobbyn · Jasmine Dumas · Remko Duursma · Mark Edmondson · Paul Egeler · Manuel Fernandez · Rich FitzJohn · Robert Flight · Zachary Foster · Auriel Fournier · Carl Ganz · Duncan Garmonsway · Sharla Gelfand · David Gohel · Laura Graham · Charles Gray · Corinna Gries · Julia Gustavsen · W Kyle Hamilton · Ivan Hanigan · Jeff Hanson · Ted Hart · Nujcharee Haswell · Verena Haunschmid · Rafael Pilliard Hellwig · Bea Hernandez · Jim Hester · Peter Hickey · Roel M. Hogervorst · Jeff Hollister · Sean Hughes · Najko Jahn · TD James · Tamora D James · Soumya Kalra · Michael Kane · Andee Kaplan · Hazel Kavılı · Os Keyes · Michael Koontz · Anna Krystalli · Erin LeDell · Thomas Leeper · Stephanie Locke · Robin Lovelace · Julia Stewart Lowndes · Tim Lucas · Andrew MacDonald · Jesse Maegan · Tristan Mahr · Ben Marwick · Miles McBain · Lucy D’Agostino McGowan · Amelia McNamara · Elaine McVey · Bryce Mecum · Francois Michonneau · Jessica Minnier · Ross Mounce · Lincoln Mullen · Matt Mulvahill · Dillon Niederhut · Jakub Nowosad · Paul Oldham · Jeroen Ooms · Philipp Ottolinger · Mark Padgham · Edzer Pebesma · Nistara Randhawa · Neal Richardson · tyler rinker · Emily Robinson · Bob Rudis · Kent Russel · Francisco Rodriguez Sanchez · Alicia Schep · Julia Silge · Peter Slaughter · Mike Smith · Tuija Sonkkila · Gaurav Sood · Adam Sparks · Joseph Stachelek · Irene Steves · Michael Sumner · Sarah Supp · Andy Teucher · Jennifer Thompson · Joe Thorley · Tiffany Timbers · Tim Trice · Ted Underwood · Kevin Ushey · Josef Uyeda · Frans van Dunné · Remi Vergnon · Claudia Vitolo · Ben Ward · Elin Waring · Leah Wasser · Stefan Widgren · Luke Winslow · David Winter · Kara Woo · Lauren Yamane · Taras Zakharko · Hao Zhu · Naupaka Zimmerman "],
["policies.html", "Chapter 5 Onboarding policies 5.1 Package submission 5.2 Aims and Scope 5.3 Package overlap 5.4 Role of the rOpenSci team 5.5 Ownership of packages 5.6 Package removal 5.7 Quality commitment 5.8 Maintainer responsiveness 5.9 Code of Conduct", " Chapter 5 Onboarding policies 5.1 Package submission For a package to be considered for the rOpenSci suite, package authors must initiate a request on the ropensci/onboarding repository. Packages are reviewed for quality, fit, documentation, clarity and the review process is quite similar to a manuscript review (see our packaging guide and reviewing guide for more details). Unlike a manuscript review, this process will be an ongoing conversation. Once all major issues and questions, and those addressable with reasonable effort, are resolved, the editor assigned to a package will make a decision (accept, hold, or reject). Rejections are usually done early (before the review process begins), but in rare cases a package may also be rejected after review &amp; revision. It is ultimately editor’s decision on whether or not to reject the package based on how the reviews are addressed. Communication between submitters, reviewers and editors will first and foremost take place on GitHub, although you can choose to contact the editor by email or Slack for certain issues. When submitting a package please make sure your GitHub notification settings make it unlikely you will miss a comment. The submitter can choose to have their submission put on hold (editor applies the holding label). The holding status will be revisited every 3 months, and after one year the issue will be closed. If the submitter hasn’t requested a holding label, but is simply not responding, we should close the issue within one month after the last contact intent. This intent will include a comment tagging the submitter, but also an email using the email address listed in the DESCRIPTION of the package which is one of the rare cases where the editor will try to contact the author by email. If a submission was closed and the author wishes to re-submit, they’ll have to start a new submission. If the package is still in scope, the author will have to respond to the initial reviews before the editor starts looking for new reviewers. 5.2 Aims and Scope rOpenSci aims to support packages that support reproducible research and managing the data lifecycle for scientists. Packages submitted to rOpenSci should fit into one or more of the following categories. If you are unsure whether your package fits into one of these categories, please open an issue as a pre-submission inquiry (Examples). As as this is a living document, these categories may change through time and not all previously onboarded packages would be in-scope today. While we strive to be consistent, we evaluate packages on a case-by-case basis and may make exceptions. Please note that rOpenSci package development happen in different spaces: unconferences, internal development by staff, and onboarding which can be confusing. The emphasis of the unconference is on experimentation, exploration and community-building - participants work on all kinds of things that wouldn’t be in scope for onboarding. Similarly, some of the software developed by rOpenSci staff is focused on filling gaps in R infrastructure and wouldn’t be in-scope. 5.2.1 Package categories data retrieval: Packages for accessing and download data from online sources with scientific applications. Our definition of scientific applications is broad, including data storage services, journals, and other remote servers, as many data sources may be of interest to researchers. However, retrieval packages should be focused on data sources / topics, rather than services. For example a general client for Amazon Web Services data storage would not be in-scope. (Examples: rotl, gutenbergr) data extraction: Packages that aid in retrieving data from unstructured sources such as text, images and PDFs, as well as parsing scientific data types and outputs from scientific equipment. Statistical/ML libraries for modeling or prediction are typically not included in this category, but trained models that act as utilities (e.g., for optical character recognition), may qualify. (Examples: tabulizer, robotstxt, genbankr) database access: Bindings and wrappers generic database APIs (Example: rrlite) data munging: Packages for processing data from formats above. This area does not include broad data manipulations tools such as reshape2 or tidyr, but rather tools for handling data in specific scientific formats. (Example: plateR) data deposition: Packages that support deposition of data into research repositories, including data formatting and metadata generation. (Examples EML) reproducibility: Tools that facilitate reproducible research. This includes packages that facilitate use of version control, provenance tracking, automated testing of data inputs and statistical outputs, citation of software and scientific literature. It does not include general tools for literate programming (e.g., R markdown extensions not under the previous topics). (Example assertr) In addition, we have some specialty topics with a slightly broader scope. geospatial data: We accept packages focused on accessing geospatial data, manipulating geospatial data, and converting between geospatial data formats. (Example: rgeospatialquality, osmplotr). text analysis: We are currently piloting a sub-specialty area for text analysis which includes implementation of statistical/ML methods for analyzing or extracting text data. This does not include packages with new methods, but only implementation or wrapping of previously published methods. As this is a pilot, the scope for this area is not fully defined and we are still developing a reviewer base and process for this area. Please open a pre-submission inquiry if you are considering submitting a package that falls under this topic. 5.2.2 Other Scope Considerations Packages should be general in that they should solve a problem as broadly as possible while maintaining a coherent user interface and code base. For instance if several data sources use an identical API, we prefer a package that provides access to all the data sources, rather than just one. Here are some types of packages we are unlikely to accept: Packages that wrap or implement statistical or machine learning methods. We are not organized so as to review the correctness of these methods. (But see “text analysis”, above) Exploratory data analysis packages that visualize or summarize data. General workflow or package development support packages We encourage submitting packages not accepted to rOpenSci to submit to CRAN, BioConductor, as well as other R package development initiatives (e.g., cloudyr), and software journals such as JOSS, JSS, or the R journal. Note that not all packages developed internally by rOpenSci or through our events or collaborations are in-scope for onboarding process. 5.3 Package overlap rOpenSci encourages competition among packages, forking and re-implementation as they improve options of users overall. However, as we want packages in the rOpenSci suite to be our top recommendations for the tasks they perform, we aim to avoid duplication of functionality of existing R packages in any repo without significant improvements. An R package that replicates the functionality of an existing R package may be considered for inclusion in the ROpenSci suite if it significantly improves on alternatives in any repository (RO, CRAN, BioC) by being: More open in licensing or development practices. Broader in functionality (e.g., providing access to more data sets, providing a greater suite of functions), but not only by duplicating additional packages Better in usability and performance Actively maintained while alternatives are poorly or no longer actively maintained These factors should be considered as a whole to determine if the package is a significant improvement. A new package would not meet this standard only by following our package guidelines while others do not, unless this leads to a significant difference in the areas above. We recommend that packages highlight differences from and improvements over overlapping packages in their README and/or vignettes. We encourage developers whose packages are not accepted due to overlap to still consider submittal to other repositories or journals. 5.4 Role of the rOpenSci team Package authors will continue to maintain and develop their software after acceptance into rOpenSci. Unless explicitly added as collaborators, the rOpenSci team will not interfere much with day to day operations. However, this team may intervene with critical bug fixes, or address urgent issues if package authors do not respond in a timely manner. 5.5 Ownership of packages Authors of contributed packages essentially maintain the same ownership they had prior to their package joining the rOpenSci suite. Contributors will have write access to their repositories, but will need an rOpenSci staff member to add any new contributors. 5.6 Package removal In the unlikely scenario that a contributor of a package requests removal of their package from the suite, we retain the right to maintain a version of the package in our suite for archival purposes. 5.7 Quality commitment rOpenSci strives to develop and promote high quality research software. To ensure that your software meets our criteria, we review all of our submissions as part of the onboarding process, and even after acceptance will continue to chime in with improvements and bug fixes. Despite our best efforts to support contributed software, errors are the responsibility of individual maintainers. Buggy, unmaintained software may be removed from our suite at any time. 5.8 Maintainer responsiveness If package maintainers do not respond in a timely manner to requests for package fixes from CRAN or from us, we will remind the maintainer a number of times, but after 3 months (or shorter time frame, depending on how critical the fix is) we will make the changes ourselves. The above is a bit vague, so the following are a few areas of consideration. Examples where we’d want to move quickly: Package foo is depended on by 1 or more packages on CRAN, and foo is broken, and thus would break its reverse dependencies. Package bar may not have reverse dependencies on CRAN, but is widely used, thus quickly fixing problems is of greater importance. Examples where we can wait longer: Package hello is not on CRAN, or on CRAN, but has no reverse dependencies. Package world needs some fixes. The maintainer has responded but is simply very busy with a new job, or other reason, and will attend to soon. We urge package maintainers to make sure they are receiving GitHub notifications, as well as making sure emails from rOpenSci staff and CRAN maintainers are not going to their spam box. Authors of onboarded packages will be invited to the rOpenSci Slack to chat to the rOpenSci team and the greater rOpenSci community. Anyone can also discuss with the rOpenSci community on rOpenSci discussion forum. Should authors abandon the maintenance of an actively used package in our suite, we will consider petitioning CRAN to transfer package maintainer status to rOpenSci. 5.9 Code of Conduct We are committed to providing a friendly, safe and welcoming environment for all, regardless of gender, sexual orientation, disability, ethnicity, religion, or similar personal characteristic. Please avoid using overtly sexual nicknames or other nicknames that might detract from a friendly, safe and welcoming environment for all. Please be kind and courteous. There’s no need to be mean or rude. Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer. Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works. We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behavior. We interpret the term “harassment” as including the definition in the Citizen Code of Conduct; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don’t tolerate behavior that excludes people in socially marginalized groups. Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact us at info@ropensci.org immediately with a capture (log, photo, email) of the harassment if possible. Whether you’re a regular contributor or a newcomer, we care about making this community a safe place for you and we’ve got your back. Likewise, any spamming, trolling, flaming, baiting or other attention-stealing behavior are not welcome. Avoid the use of personal pronouns in code comments or documentation. There is no need to address persons when explaining code (e.g. “When the developer”) This CoC adapted from the io.js CoC, adapted from Rust’s CoC. "],
["onboarding-guide-for-authors.html", "Chapter 6 Onboarding Guide for Authors", " Chapter 6 Onboarding Guide for Authors This concise guide presents the onboarding process for you as a package author. Consult our policies see if your package meets our criteria for fitting into our suite and not overlapping with other packages. If you are unsure whether a package meets our criteria, feel free to open an issue as a pre-submission inquiry to ask if the package is appropriate. Read and follow our packaging style guide to ensure your package meets our style and quality criteria. If you would like your package also submitted to Journal of Open-Source Software (JOSS), it should include a paper.md file describing the package. More detail on JOSS’s requirements can be found at their website. If you choose this option you should not submit your package to JOSS separately. It will be evaluated by JOSS based on the rOpenSci review. Next, open a new issue in this repository and fill out the template. Communication between submitters, reviewers and editors will first and foremost take place on GitHub, although you can choose to contact the editor by email or Slack for certain issues. When submitting a package please make sure your GitHub notification settings make it unlikely you will miss a comment. An editor will review your submission within 5 business days and respond with next steps. The editor may assign the package to reviewers, request that the package be updated to meet minimal criteria before review, or reject the package due to lack of fit or overlap. If your package meets minimal criteria, the editor will assign 1-3 reviewers. They will be asked to provide reviews as comments on your issue within 3 weeks. We ask that you respond to reviewers’ comments within 2 weeks of the last-submitted review, but you may make updates to your package or respond at any time. Here is an author response example. We encourage ongoing conversations between authors and reviewers. See the reviewing guide for more details. Once your package is approved, we will provide further instructions on transferring your repository to the rOpenSci repository. Our code of conduct is mandatory for everyone involved in our review process. "],
["onboarding-guide-for-reviewers.html", "Chapter 7 Onboarding Guide for Reviewers 7.1 Preparing your review 7.2 Submitting the Review 7.3 Review follow-up {followupreviewer}", " Chapter 7 Onboarding Guide for Reviewers Thanks for accepting to review a package for rOpenSci! This chapter consists of our guidelines to prepare, submit and follow-up on your review. You might contact the editor in charge of the submission for any question you might have about the process or your review. Please strive to complete your review within 3 weeks of accepting a review request. We will aim to remind reviewers of upcoming and past due dates. Editors may assign additional or alternate reviewers if a review is excessively late. 7.1 Preparing your review 7.1.1 General guidelines To review a package, please begin by copying our review template and using it as a high-level checklist. In addition to checking off the minimum criteria, we ask you provide general comments addressing the following: Does the code comply with general principles in the Mozilla reviewing guide? Does the package comply with the rOpenSci packaging guide? Are there improvements that could be made to the code style? Is there code duplication in the package that should be reduced? Are there user interface improvements that could be made? Are there performance improvements that could be made? Is the documentation (installation instructions/vignettes/examples/demos) clear and sufficient? If you you have your own relevant data/problem, work through it with the package. You’ll find rough edges and use-cases the author didn’t. Please be respectful and kind to the authors in your reviews. Our code of conduct is mandatory for everyone involved in our review process. We expect you to submit your review withing 3 weeks, depending on the deadline set by the editor. Please contact the editor directly or in the submission thread to inform them about possible delays. We encourage you to use automated tools to facilitate your reviewing. These include: Checking the package’s logs on its continuous integration services (Travs-CI, Codecov, etc.) Running devtools::check() and devtools::test() on the package to find any errors that may be missed on the author’s system. Using the covr package to examine the extent of test coverage. Using the goodpractice package (goodpractice::gp()) to identify likely sources of errors and style issues. Most exceptions will need to be justified by the author in the particular context of their package. Using spelling::spell_check_package() (and spelling::spell_check_files(&quot;README.Rmd&quot;)) to find spelling errors. 7.1.2 Experience from past reviewers First-time reviewers may find it helpful to read (about) some previous reviews. In general you can find submission threads of onboarded packages here. Here are a few chosen examples of reviews (note that your reviews do not need to be as long as examples): rtika review 1 and review 2 NLMR review 1 and review 2 bowerbird pre-review comment, review 1, review 2. rusda review (from before we had a review template) You can read blog posts written by reviewers on our blog via this link. In particular, in this blog post by Mara Averick read her take about the “naïve user” role a reviewer can take to provide useful feedback even without being experts of the package’s topic or implementation, by asking themselves “What did I think this thing would do? Did it do it? What are things that scare me off?”. In another blog post Verena Haunschmid explains how she alternated between using the package and checking its code. As both a former reviewer and package author Adam Sparks wrote wrote “[write] a good critique of the package structure and best coding practices. If you know how to do something better, tell me. It’s easy to miss documentation opportunities as a developer, as a reviewer, you have a different view. You’re a user that can give feedback. What’s not clear in the package? How can it be made more clear? If you’re using it for the first time, is it easy? Do you know another R package that maybe I should be using? Or is there one I’m using that perhaps I shouldn’t be? If you can contribute to the package, offer.” 7.1.3 Feedback on the process We encourage you to ask questions and provide feedback on the review process on our forum. 7.2 Submitting the Review When your review is complete, paste it as a comment into the package onboarding issue. Additional comments are welcome in the same issue as a package onboarding request. We hope that package reviews will work as an ongoing conversation with the authors as opposed to a single round of reviews typical of manuscripts. You may also submit issues or pull requests directly to the package repo if you choose, but if you do, please comment about them and link to them in the onboarding repo comment thread so we have a centralized record and text of your review. Please include an estimate of how many hours you spent on your review at the end of your review. 7.3 Review follow-up {followupreviewer} Authors should respond to the review within 2 weeks with their changes to the package in response to your review. At this stage, we ask that you respond as to whether the change sufficiently address any issues raised in your review. We encourage ongoing discussion between package authors and reviewers, and you may ask editors to clarify issues in the review thread, as well. "],
["onboarding-guide-for-editors.html", "Chapter 8 Onboarding Guide for Editors 8.1 EiC Responsibilities 8.2 Handling Editor’s Checklist 8.3 Responding to out-of-scope submissions", " Chapter 8 Onboarding Guide for Editors Onboarding at rOpenSci is managed by a team of editors. We are piloting a system of a rotating Editor-in-Chief (EiC). This chapter presents the responsabilities of the Editor-in-Chief, of any editor in charge of a submission, and how to respond to an out-of-scope submission. If you’re a guest editor, thanks for helping! Please contact the editor who invited you to handle a submission for any question you might have. 8.1 EiC Responsibilities The EiC serves for 3 months or a time agreed to by all members of the editorial board. The EiC plays the following roles Watch all issues posted to the onboarding repo: Assigns packages to other editors, including self, to handle. Mostly this just rotates among editors, unless the EiC thinks an editor is particularly suited to a package, or an editor rejects due to being too busy/conflict of interest. Raises scope/overlap issue with all editors if they see an ambiguous case. This may also be done by handling editors (see below). To initiate discussion, this is posted to the rOpenSci Slack onboarding channel, tagging all editors. Responds to pre-submission inquiries and meta issues posted to the onboarding repo, similarly pinging channel if discussion needed. But editors should all feel free to chime in on these if they want. See this section about how to respond to out-of-scope (pre-) submissions. Responds to referrals from JOSS or other publication partners. Monitors pace of review process and reminds other editors to move packages along as needed. 8.2 Handling Editor’s Checklist 8.2.1 Upon submission: Tag issue with 1/editor-checks tag and assign a main editor if you haven’t already. Please strive to finish the checks and start looking for reviewers within 5 working days. Use the editor template to guide initial checks and record your respose to the submission. Check that template has been properly filled out Check against policies for fit and overlap. Initiate discussion via slack #onboarding channel if needed for edge cases that haven’t been caught by previous checks by the editor-in-chief. If reject, see this section about how to respond. Check that mandatory parts of template are complete. If not, direct authors toward appropriate instructions. Run run automated tests: spelling::spell_check_package(), goodpractice::gp() (most exceptions will need to be justified by the author in the particular context of their package.), devtools::spell_check(). Run covr::package_coverage() using NOT_CRAN if needed, as well. Check that documentation is generated using roxygen2, not by hand (this isn’t part of automatic tests yet). Report relevant outputs in the issue thread. For packages needing continuous integration on multiple platforms (cf criteria in this section of the CI chapter) make sure the package gets tested on multiple platforms (having the package built on both Travis and Appveyor for instance). Wherever possible when asking for changes direct authors to automatic tools such as usethis and styler, and to online resources (sections of this guide, sections of the R packages book) to make your feedback easier to use. Example of editor’s checks. If initial checks show major gaps, request changes before assigning reviewers. If the package raises a new issue for rOpenSci policy, start a conversation in Slack or open a discussion on the rOpenSci forum to discuss it with other editors (examplehttps://discuss.ropensci.org/t/overlap-policy-for-package-onboarding/368) 8.2.2 Assign reviewers: Switch numbered tag to 2/seeking-reviewers Ask author to add a rOpenSci review badge to their README. Badge URL is https://badges.ropensci.org/&lt;issue_id&gt;_status.svg. Full link should be: [![](https://badges.ropensci.org/&lt;issue_id&gt;_status.svg)](https://github.com/ropensci/onboarding/issues/&lt;issue_id&gt;) Use the #onboarding slack channel for discussion about potential reviewers. Use the email template if needed for inviting reviewers When inviting reviewers, include something like “if I don’t hear from you in a week, I’ll assume you are unable to review,” so as to give a clear deadline when you’ll move on to looking for someone else. Assign a due date 3 weeks after all reviewers have been found. Once two or more reviewers are found, assign reviewer by tagging in the issue with the following format: Reviewer: (???) Reviewer: (???) Due date: YYYY-MM-DD Switch numbered tag to 3/reviewers-assigned once reviewers are assigned. Invite authors and reviewers to rOpenSci Slack if they aren’t on already. 8.2.3 During review: Check in with reviewers and authors occasionally. Offer clarification and help as needed. In general aim for 3 weeks for review, 2 weeks for subsequent changes, and 1 week for reviewer approval of changes. Upon all reviews being submitted, change the review status tag to 4/review-in-awaiting-changes to update the reminder bot. If the author stops responding, refers to the policies and/or ping the other editors in the Slack channel for discussion. Importantly, if a reviewer was assigned to a closed issue, contact them when closing the issue to explain them the decision and thank them once again for their work, and make a note in our database to assign them to a submission with high chances of smooth onboarding next time (e.g. a package author who has already submitted packages to us). Upon changes being made, change the review status tag to 5/awaiting-reviewer-response. 8.2.4 After review: Change the status tag to 6/approved. You can use the comment template Add review/er information to the review database. If authors intend to submit to CRAN, direct them to the section about CRAN gotchas and offer to provide support through this process. Ask authors to migrate to ropensci Create a two-person team in the ropensci organization, named for the package, with yourself and the package author as members. Have the author transfer the repository to ropensci Go to the repository settings in the ropensci organization and give the author “Admin” access to the repository. Ask author to: Add rOpenSci footer to README [![ropensci_footer](https://ropensci.org/public_images/ropensci_footer.png)](https://ropensci.org) Add a CodeMeta file by running codemetar::write_codemeta() (codemetar GitHub repo) Change any needed links, such those for CI badges Re-activate CI services For Travis, activating the project in the ropensci account should be sufficient For Appveyor, tell the author to update the GitHub link in their badge, but do not transfer the project: Appveyor projects should remain under the authors’ account. The badge is [![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/ropensci/pkgname?branch=master&amp;svg=true)](https://ci.appveyor.com/project/individualaccount/pkgname). For CodeCov, the webhook may need to be reset by the author. Close the onboarding issue. 8.2.5 For joint JOSS submissions: After repo is transferred and admin rights assigned, have author generate a new release with a DOI. Ask author to submit package via http://joss.theoj.org/papers/new Watch for paper to pop up at http://joss.theoj.org/papers, then add the following comment to the submission thread: This submission has been accepted to rOpenSci. The review thread can be found at [LINK TO ONBOARDING ISSUE] 8.2.6 Package promotion: Ask authors to write either a blog post or a tech-notes post for the package, as appropriate, and ping Stefanie Butland, rOpenSci community manager. Alert maintainers of appropriate task views Direct the author to the chapters of the guide about package releases, marketing and GitHub grooming. 8.3 Responding to out-of-scope submissions Thank authors for their submission, explain the reasons of the decision, and direct them to other publication venues if relevant, and to rOpenSci discuss forum. Use wording from Aims and scope in particular regarding the evolution of scope over time, and the overlap and differences between unconf/staff/onboarding development. Examples of out-of-scope submissions and responses. "],
["collaboration.html", "Chapter 9 Collaboration Guide 9.1 Make your repo contribution- and collaboration- friendly 9.2 Working with collaborators", " Chapter 9 Collaboration Guide Having contributors will improve your package, and if you onboard some of them as package authors with write permissions to the repo, your package will be more sustainably developed. This chapter contains our guidance for collaboration, in a section about making your repo contribution- and collaboration- friendly by infrastructure (code of conduct, contribution guidelines, issue labels); and a section about how to collaborate with new contributors, in particular in the context of the rOpenSci organization. 9.1 Make your repo contribution- and collaboration- friendly 9.1.1 Code of conduct We require that you use a code of conduct such as the Contributor Covenant in developing your package. You can document your code of conduct in a CODE_OF_CONDUCT.md or CONDUCT.md file in the package root directory, and linking to this file from the README.md file. devtools::use_code_of_conduct() will add the Contributor Covenant template to your package. 9.1.2 Contributing guide We have templates for issue, pull request and contributing guidelines that you can find in this GitHub repository along with some instructions to insert them into your repository. You can tweak them a bit depending on your workflow and package: e.g. in CONTRIBUTING.md make sure contributors have instructions for running local test if they are not trivial. CONTRIBUTING.md can also contain some details about how you’ll acknowledge contributions (see this section), and the roadmap of your package, cf this example. 9.1.3 Issue labelling You can use labels such as “help wanted” and “good first issue” to help potential collaborators, including newbies, find your repo. Cf GitHub article. You can also use the “Beginner” label. See examples of beginner issues over all ropensci repos. 9.2 Working with collaborators 9.2.1 Onboarding collaborators There’s no general rOpenSci rule as to how you should onboard collaborators. You should increase their rights to the repo as you gain trust, and you should definitely ackonwledge contributions (seethis section). You can ask a new collaborator to make PRs (see following section for assessing a PR locally, i.e. beyond CI checks) to dev/master and assess them before merging, and after a while let them push to master, although you might want to keep a system of PR reviews… even for yourself once you have team mates! A possible model for onboarding collaborators is provided by Jim Hester in his lintr repo. If your problem is recruiting collaborators, you can post an open call like Jim Hester’s on Twitter, GitHub, and as an rOpenSci package author, you can ask for help in rOpenSci slack and ask rOpenSci team for ideas for recruiting new collaborators. 9.2.2 Working with collaborators (including yourself) You could implement the gitflow&quot; philosophy as explained by Amanda Dobbyn in this blog post. To asses PR cf “Explore and extend a pull request” in happygitwithr.com 9.2.3 Be generous with attributions If someone contributes to your repository consider adding them in DESCRIPTION, as contributor (“ctb”) for small contributions, author (“aut”) for bigger contributions. Also consider adding their name near the feature/bug fix line in NEWS.md We recommend your being generous with such acknowledgements. As a reminder from our packaging guidelines if your package was reviewed and you feel that your reviewers have made a substantial contribution to the development of your package, you may list them in the Authors@R field with a Reviewer contributor type (&quot;rev&quot;), like so: person(&quot;Bea&quot;, &quot;Hernández&quot;, role = &quot;rev&quot;, comment = &quot;Bea reviewed the package for ropensci, see &lt;https://github.com/ropensci/onboarding/issues/116&gt;&quot;), Only include reviewers after asking for their consent. Read more in this blog post “Thanking Your Reviewers: Gratitude through Semantic Metadata”. Note that ‘rev’ will raise a CRAN NOTE unless the package is built using R v3.5. As of June 2018 you need to use roxygen2 dev version for the list of authors in the package-level documentation to be compiled properly with the “rev” role (because this is a MARC role not included yet in royxgen2 CRAN version from February 2017). Please do not list editors as contributors. Your participation in and contribution to rOpenSci is thanks enough! 9.2.4 Welcoming collaborators to rOpenSci If you give someone write permissions to the repository, please contact one of the editors or Stefanie Butland so that this new contributor might get invited to ropensci GitHub organization (instead of being outside collaborators) get invited to rOpenSci slack workspace. "],
["releasing.html", "Chapter 10 Releasing a package 10.1 Versioning 10.2 Releasing 10.3 News file", " Chapter 10 Releasing a package Your package should have different versions over time: snapshots of a state of the package that you can release to CRAN for instance. These versions should be properly numbered, released and described in a NEWS file. More details below. Note that you could streamline the process of updating NEWS and versioning your package by using the fledge package. 10.1 Versioning We strongly recommend that rOpenSci packages use semantic versioning. A detailed explanation is available on the description chapter. 10.2 Releasing Git tag each release after every submission to CRAN. [more info](https://help.github.com/articles/creating-releases/] 10.3 News file A NEWS file describing changes associated with each version makes it easier for users to see what’s changing in the package and how it might impact their workflow. You must add one for your package, and make it easy to read. It is mandatory to use a NEWS or NEWS.md file in the root of your package. We recommend using NEWS.md to make the file more browsable. Please use our exampleNEWS file as a model. You can find a good NEWS file in the wild in the taxize package repo for instance. If you use NEWS, add it to .Rbuildignore, but not if you use NEWS.md Update the news file before every CRAN release, with a section with the package name, version and date of release, like (as seen in our exampleNEWS file: foobar 0.2.0 (2016-04-01) ========================= Under that header, put in sections as needed, including: NEW FEATURES, MINOR IMPROVEMENTS, BUG FIXES, DEPRECATED AND DEFUNCT, DOCUMENTATION FIXES and any special heading grouping a large number of changes. Under each header list items as needed (as seen in our exampleNEWS file. For each item give a description of the new feature, improvement, bug fix, or deprecated function/feature. Link to any related GitHub issue like (#12). The (#12) will resolve on GitHub in Releases to a link to that issue in the repo. After you have added a git tag and pushed up to GitHub, add the news items for that tagged version to the Release notes of a release in your GitHub repo with a title like pkgname v0.1.0. See GitHub docs about creating a release. New CRAN releases will be tweeted about automatically by roknowtifier and written about in our biweekly newsletter but see next chapter about marketing about how to inform more potential users about the release. "],
["marketing.html", "Chapter 11 Marketing your package", " Chapter 11 Marketing your package We will help you promoting your package but here are some more things to keep in mind. If you hear of an use case of your package, please send the link to Scott Chamberlain (e.g. via Slack or scott@ropensci.org) for inclusion in the rOpenSci biweekly newsletter. You can also add a link to the use case in an “use cases in the wild” section of your README. When you release a new version of your package or release it to CRAN for the first time, Make a pull request to R Weekly with a line about the release under the “New Releases” section (or “New Packages” for the first GitHub/CRAN release). Tweet about it using the “#rstats” hashtag and tag rOpenSci! Example. First version of the (???) ‘ssh’ 📦is on #rstats CRAN: https://t.co/eXlhXLnOzT Secure Shell (SSH) Client for R — Jeroen Ooms ((???)) 5 de juny de 2018 Consider submitting a technote about the release to rOpenSci technotes blog. Contact Stefanie Butland, rOpenSci community manager, (e.g. via Slack or stefanie@ropensci.org ). The guidelines about contributing a blog post can be found here). Submit your package to lists of packages such as CRAN Task Views, and rOpenSci non-CRAN Task Views. "],
["grooming.html", "Chapter 12 GitHub Grooming 12.1 Make your repository more discoverable 12.2 Market your own account", " Chapter 12 GitHub Grooming rOpenSci packages are currently in their vast majority developed on GitHub. Here are a few tips to leverage the platform in a section about making your repo more discoverable and a section about marketing your own GitHub account after onboarding your package. 12.1 Make your repository more discoverable 12.1.1 GitHub repo topics GitHub repo topics help browsing and searching GitHub repos, and are digested by codemetar for rOpenSci registry keywords. We recommend: Adding “r”, “r-package” and “rstats” as topics to your package repo. Adding any other relevant topics to your package repo. We might make suggestions to you after your package is onboarded. 12.1.2 GitHub linguist GitHub linguist will assign a language for your repo based on the files it contains. Some packages containing a lot of C++ code might get classified as C++ rather than R packages, which is fine and shows the need for the “r”, “r-package” and “rstats” topics. We recommend overriding GitHub linguist by adding or modifying a .gitattributes to your repo in two cases: If you store html files in non standard places (not in docs/, e.g. in vignettes/) use the documentation overrides. Add *.html linguist-documentation=true to .gitattributes (Example in the wild) If your repo contains code you haven’t authored, e.g. JavaScript code, add inst/js/* linguist-vendored to .gitattributes (Example in the wild) This way the language classification and statistics of your repository will more closely reflect the source code it contains, as well as making it more discoverable. More info about GitHub linguist overrides here. 12.2 Market your own account As the author of an onboarded package, you are now a member of the ropensci GitHub organization. By default organization memberships are private, see how to make it public in GitHub docs. Even after that your package repo has been transferred to rOpenSci, you can pin it under your own account. In general we recommend adding at least an avatar (which doesn’t need to be your face!) and your name to your GitHub profile. "],
["evolution.html", "Chapter 13 Package evolution - changing stuff in your package 13.1 Philosophy of changes 13.2 Parameters: changing parameter names 13.3 Functions: changing function names 13.4 Functions: deprecate &amp; defunct", " Chapter 13 Package evolution - changing stuff in your package This chapter presents our guidance for changing stuff in your package: changing parameter names, changing function names, deprecting functions. This chapter was initially contributed as a tech note on rOpenSci website by Scott Chamberlain, read the original here. 13.1 Philosophy of changes Everyone’s free to have their own opinion about how freely parameters/functions/etc. are changed in a library - rules about package changes are not enforced by CRAN or otherwise. Generally, as a library gets more mature, changes to user facing methods (i.e., exported functions in an R package) should become very rare. Libraries that are depended on by many other libraries are likely to be more careful, and should be, about changes. 13.2 Parameters: changing parameter names Sometimes parameter names must be changed for clarity, or some other reason. A possible approach is to catch all parameters passed in to the function and check against some list of parameters, and stop or warn with a meaningful message. foo_bar &lt;- function(x, y) { calls &lt;- names(sapply(match.call(), deparse))[-1] if(any(&quot;x&quot; %in% calls)) { stop(&quot;use &#39;y&#39; instead of &#39;x&#39;&quot;) } y^2 } foo_bar(x = 5) #&gt; Error in foo_bar(x = 5) : use &#39;y&#39; instead of &#39;x&#39; Or instead of stopping with error, you could check for use of x parameter and set it to y internally. foo_bar &lt;- function(x, y) { calls &lt;- names(sapply(match.call(), deparse))[-1] if(any(&quot;x&quot; %in% calls)) { y &lt;- x } y^2 } foo_bar(x = 5) #&gt; 25 Be aware of the parameter .... If your function has ..., and you have already removed a parameter (lets call it z), a user may have older code that uses z. When they pass in z, it’s not a parameter in the function definition, and will likely be silently ignored - not what you want. So do make sure to always check for removed parameters moving forward since you can’t force users to upgrade. 13.3 Functions: changing function names If you must change a function name, do it gradually, as with any package changes. Let’s say you have a function foo. foo &lt;- function(x) x + 1 However, you want to change the function name to bar. Instead of simply changing the function name and foo no longer existing straight away, in the first version of the package that bar appears, make an alias like: #&#39; foo - add 1 to an input #&#39; @export foo &lt;- function(x) x + 1 #&#39; @export #&#39; @rdname foo bar &lt;- foo With the above, the user can use either foo() or bar() - either will do the same thing, as they are the same function. It’s also useful to have a message but then you’ll only want to throw that message when they use the old function name, e.g., #&#39; foo - add 1 to an input #&#39; @export foo &lt;- function(x) { if (as.character(match.call()[[1]]) == &quot;foo&quot;) { warning(&quot;please use bar() instead of foo()&quot;, call. = FALSE) } x + 1 } #&#39; @export #&#39; @rdname foo bar &lt;- foo After users have used the package version for a while (with both foo and bar), in the next version you can remove the old function name (foo), and only have bar. #&#39; bar - add 1 to an input #&#39; @export bar &lt;- function(x) x + 1 13.4 Functions: deprecate &amp; defunct To remove a function from a package (let’s say your package name is helloworld), you can use the following protocol: Mark the function as deprecated in package version x (e.g., v0.2.0) In the function itself, use .Deprecated() like: foo &lt;- function() { .Deprecated(msg = &quot;&#39;foo&#39; will be removed in the next version&quot;) } There’s options in .Deprecated for specifying a new function name, as well as a new package name, which makes sense when moving functions into different packages. The message that’s given by .Deprecated is a warning, so can be suppressed by users with suppressWarnings() if desired. Make a man page for deprecated functions like: #&#39; Deprecated functions in helloworld #&#39; #&#39; These functions still work but will be removed (defunct) in the next version. #&#39; #&#39; \\itemize{ #&#39; \\item \\code{\\link{foo}}: This function is deprecated, and will #&#39; be removed in the next version of this package. #&#39; } #&#39; #&#39; @name helloworld-deprecated NULL This creates a man page that users can access like ?helloworld-deprecated and they’ll see in the documentation index. Add any functions to this page as needed, and take away as a function moves to defunct (see below). In the next version (v0.3.0) you can make the function defunct (that is, completely gone from the package, except for a man page with a note about it). In the function itself, use .Defunct() like: foo &lt;- function() { .Defunct(msg = &quot;&#39;foo&#39; has been removed from this package&quot;) } Note that the message in .Defunct is an error, so the function stops - whereas .Deprecated returned a warning, letting the function proceed. In addition, it’s good to add ... to all defunct functions so that if users pass in any parameters they’ll get the same defunct message instead of a unused argument message, so like: foo &lt;- function(...) { .Defunct(msg = &quot;&#39;foo&#39; has been removed from this package&quot;) } Without ... gives: foo(x = 5) #&gt; Error in foo(x = 5) : unused argument (x = 5) And with ... gives: foo(x = 5) #&gt; Error: &#39;foo&#39; has been removed from this package Make a man page for defunct functions like: #&#39; Defunct functions in helloworld #&#39; #&#39; These functions are gone, no longer available. #&#39; #&#39; \\itemize{ #&#39; \\item \\code{\\link{foo}}: This function is defunct. #&#39; } #&#39; #&#39; @name helloworld-defunct NULL This creates a man page that users can access like ?helloworld-defunct and they’ll see in the documentation index. Add any functions to this page as needed. You’ll likely want to keep this man page indefinitely. "],
["contributingguide.html", "Chapter 14 Contributing Guide 14.1 Pre-requisities 14.2 Reporting issues or feature requests 14.3 Reporting use cases 14.4 Finding where to contribute code or documentation", " Chapter 14 Contributing Guide So you want to contribute to rOpenSci packages? Fantastic! First of all, maybe contributing to a package is not the (only) way you’ll want to get involved with rOpenSci. Check out our community page to find out all the ways to participate in the project. Thanks for wanting to contribute to rOpenSci packages. We strive to make contributing to our suite a constructive and positive experience. See our code of conduct. Regarding this guide itself, please report any suggestion via this GitHub repository. 14.1 Pre-requisities Before contributing to one of our packages, you might want to read a bit more about package development in general and our guidelines. 14.1.1 Learning about package development 14.1.1.1 Tutorials Hilary Parker’s famous blog post Writing an R package from scratch this pictorial by Matthew J Denny 14.1.1.2 Books Hadley Wickham’s R packages book Writing R extensions, the official CRAN guide Mastering Software Development in R by Roger D. Peng, Sean Kross, and Brooke Anderson Advanced R by Hadley Wickham Testing R code by Richard Cotton 14.1.1.2.1 MOOC There is a Coursera specialization corresponding to the book by Roger Peng, Sean Kross and Brooke Anderson, with a course specifically about R packages. 14.1.2 Reading about our guidelines See the whole first section, starting with the chapter about building a package 14.2 Reporting issues or feature requests If you already have a package in mind, head to its issue tracker for reporting a bug or a feature request you might have. E.g. if you have a feature request for magick, the place to fill it is https://github.com/ropensci/magick/issues 14.3 Reporting use cases If you are the author, or the reader, of an use case of one of our packages, please send the link to Scott Chamberlain (scott@ropensci.org) for inclusion in the rOpenSci biweekly newsletter. If the package you used has an “use cases in the wild” section in its README you can make a Pull Request to the GitHub repository to suggest adding your use case. 14.4 Finding where to contribute code or documentation Most our packages are developped on GitHub. We have two organizations: https://github.com/ropensci for more mature packages, https://github.com/ropenscilabs for experiments and packages that are not ready for release yet. If you already use one of our packages, you can have a look at its issue tracker and comment in one of the issues to ask the maintainer whether they’d be interested in your help. E.g. if you like taxize, the place to look is https://github.com/ropensci/taxize/issues If you’re not a passionate user of one of our packages yet, you can find one to contribute to by browsing https://github.com/ropensci for instance. In particular, you could browse issues targeted at beginner by using the contributr Shiny app by Lucy D’Agostino McGowan or by an advanced GitHub search such as this one. "],
["reviewtemplate.html", "A Review template", " A Review template ## Package Review *Please check off boxes as applicable, and elaborate in comments below. Your review is not limited to these topics, as described in the reviewer guide* - [ ] As the reviewer I confirm that there are no conflicts of interest for me to review this work (If you are unsure whether you are in conflict, please speak to your editor _before_ starting your review). #### Documentation The package includes all the following forms of documentation: - [ ] **A statement of need** clearly stating problems the software is designed to solve and its target audience in README - [ ] **Installation instructions:** for the development version of package and any non-standard dependencies in README - [ ] **Vignette(s)** demonstrating major functionality that runs successfully locally - [ ] **Function Documentation:** for all exported functions in R help - [ ] **Examples** for all exported functions in R Help that run successfully locally - [ ] **Community guidelines** including contribution guidelines in the README or CONTRIBUTING, and DESCRIPTION with `URL`, `BugReports` and `Maintainer` (which may be autogenerated via `Authors@R`). &gt;##### For packages co-submitting to JOSS &gt; &gt;- [ ] The package has an **obvious research application** according to [JOSS&#39;s definition](http://joss.theoj.org/about#submission_requirements) &gt; &gt;The package contains a `paper.md` matching [JOSS&#39;s requirements](http://joss.theoj.org/about#paper_structure) with: &gt; &gt;- [ ] **A short summary** describing the high-level functionality of the software &gt;- [ ] **Authors:** A list of authors with their affiliations &gt;- [ ] **A statement of need** clearly stating problems the software is designed to solve and its target audience. &gt;- [ ] **References:** with DOIs for all those that have one (e.g. papers, datasets, software). #### Functionality - [ ] **Installation:** Installation succeeds as documented. - [ ] **Functionality:** Any functional claims of the software been confirmed. - [ ] **Performance:** Any performance claims of the software been confirmed. - [ ] **Automated tests:** Unit tests cover essential functions of the package and a reasonable range of inputs and conditions. All tests pass on the local machine. - [ ] **Packaging guidelines**: The package conforms to the rOpenSci packaging guidelines #### Final approval (post-review) - [ ] **The author has responded to my review and made changes to my satisfaction. I recommend approving this package.** Estimated hours spent reviewing: --- ### Review Comments "],
["editortemplate.html", "B Editor’s template", " B Editor’s template ### Editor checks: - [ ] **Fit**: The package meets criteria for [fit](policies.md#fit) and [overlap](policies.md#fit) - [ ] **Automated tests:** Package has a testing suite and is tested via Travis-CI or another CI service. - [ ] **License:** The package has a CRAN or OSI accepted license - [ ] **Repository:** The repository link resolves correctly - [ ] **Archive** (JOSS only, may be post-review): The repository DOI resolves correctly - [ ] **Version** (JOSS only, may be post-review): Does the release version given match the GitHub release (v1.0.0)? --- #### Editor comments --- Reviewers: Due date: "],
["reviewrequesttemplate.html", "C Review request template", " C Review request template Editors may make use of the e-mail template below in recruiting reviewers. Dear [REVIEWER] Hi, this is [EDITOR]. [FRIENDLY BANTER]. I&#39;m writing to ask if you would be willing to review a package for rOpenSci. As you probably know, rOpenSci conducts peer review of R packages contributed to our collection in a manner similar to journals. The package, [PACKAGE] by [AUTHOR(S)], does [FUNCTION]. You can find it on GitHub here: [REPO LINK]. We conduct our open review process via GitHub as well, here: [ONBOARDING ISSUE] If you accept, note that we ask reviewers to complete reviews in three weeks. (We’ve found it takes a similar amount of time to review a package as an academic paper.) Our [reviewers guide] details what we look for in a package review, and includes links to example reviews. Our standards are detailed in our [packaging guide], and we provide reviewer [template] for you to use. If you have questions or feedback, feel free to ask me or post to the [rOpenSci forum]. {IF APPLICABLE: The authors have also chosen to jointly submit their package to the Journal of Open Source Software, so this package includes a short `paper.md` manuscript describing the software that we ask you include in your review.} Are you able to review? If you can not, suggestions for alternate reviewers are always helpful. If I don&#39;t hear from you within a week, I will assume you are unable to review at this time. Thank you for your time. Sincerely, [EDITOR] [reviewers guide]: https://ropensci.github.io/dev_guide/onboarding-guide-for-reviewers.html [packaging guide]: https://ropensci.github.io/dev_guide/https://ropensci.github.io/dev_guide/building.html [template]: https://ropensci.github.io/dev_guide/reviewtemplate.html [rOpenSci forum]: https://discuss.ropensci.org/ "],
["approvaltemplate.html", "D Approval comment template", " D Approval comment template Approved! Thanks &lt;author(s) GitHub username(s)&gt; for submitting and &lt;reviewers&#39; GithHub usernames&gt; for your reviews! &lt;optional: smiling cat emoji à la Scott&gt; To-dos: - [ ] Transfer the repo to the rOpenSci organization under &quot;Settings&quot; in your repo. I have invited you to a team that should allow you to do so. You&#39;ll be made admin once you do. - [ ] Add the rOpenSci footer to the bottom of your README &quot;``` [![ropensci_footer](https://ropensci.org/public_images/ropensci_footer.png)](https://ropensci.org)```&quot; - [ ] Fix any links in badges for CI and coverage to point to the ropensci URL. We no longer transfer Appveyor projects to ropensci Appveyor account so after transfer of your repo to the ropensci GitHub organization the badge should be `[![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/ropensci/pkgname?branch=master&amp;svg=true)](https://ci.appveyor.com/project/individualaccount/pkgname)`. - [ ] We&#39;re starting to roll out software metadata files to all ropensci packages via the Codemeta initiative, see https://github.com/ropensci/codemetar/#codemetar for how to include it in your package, after installing the package - should be easy as running codemetar::write_codemeta() in the root of your package. &lt;IF JOSS&gt; - [ ] Activate Zenodo watching the repo - [ ] Tag and create a release so as to create a Zenodo version and DOI - [ ] Submit to JOSS using the Zenodo DOI. We will tag it for expedited review. &lt;IF JOSS/&gt; Should you want to awknowledge your reviewers in your package DESCRIPTION, you can do so by making them `&quot;rev&quot;`-type contributors in the `Authors@R` field (with their consent). More info on this [here](https://ropensci.github.io/dev_guide/building.html#authorship). Welcome aboard! We&#39;d also love a blog post about your package, either a short-form intro to it (https://ropensci.org/tech-notes/) or long-form post with more narrative about its development. ((https://ropensci.org/blog/). If you are, @stefaniebutland will be in touch about content and timing. We&#39;ve started putting together a gitbook with our best practice and tips, [this chapter](https://ropensci.github.io/dev_guide/collaboration.html) starts the 3d section that&#39;s about guidance for after onboarding. Please tell us what could be improved, the corresponding repo is [here](https://github.com/ropensci/dev_guide). "],
["newstemplate.html", "E NEWS template", " E NEWS template foobar 0.2.0 (2016-04-01) ========================= ### NEW FEATURES * New function added `do_things()` to do things (#5) ### MINOR IMPROVEMENTS * Improved documentation for `things()` (#4) ### BUG FIXES * Fix parsing bug in `stuff()` (#3) ### DEPRECATED AND DEFUNCT * `hello_world()` now deprecated and will be removed in a future version, use `hello_mars()` ### DOCUMENTATION FIXES * Clarified the role of `hello_mars()` vs. `goodbye_mars()` ### (a special: any heading grouping a large number of changes under one thing) * blablabla. foobar 0.1.0 (2016-01-01) ========================= ### NEW FEATURES * released to CRAN "]
]
